import Mathlib.Algebra.Group.Basic
import Mathlib.Order.Basic
import Mathlib.Data.Fin.Basic
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Finset.Max
import Mathlib.Data.Fintype.Basic
import Mathlib.Tactic


section definitions

variable {S α : Type*} [Semigroup S] [LinearOrder α]

variable {h : ℕ}

structure MultiplicativeLabeling (S α : Type*) [Semigroup S] [LinearOrder α] where
  σ: α → α → S
  prop : ∀ x y z : α, x < y → y < z → σ x y * σ y z = σ x z

abbrev Split (α : Type*) (h : ℕ) := α → Fin h

def splitRelation (s : Split α h) (x y : α) : Prop :=
  s x = s y ∧ ∀ z, min x y ≤ z → z ≤ max x y → s z ≤ s (min x y)

def isNormalized [Fintype α] [Nonempty α] (s : Split α h) : Prop :=
  let min_α := Finset.min' Finset.univ Finset.univ_nonempty
  some (s min_α) = Finset.max Finset.univ

def isRamsey (L : MultiplicativeLabeling S α) (s : Split α h) : Prop :=
  ∀ x y : α, splitRelation s x y → L.σ x y * L.σ x y = L.σ x y

end definitions


section theorems

variable {G α : Type*} [Group G] [Fintype G] [DecidableEq G]

variable [LinearOrder α]

theorem split_relation_equiv (s : Split α h) : Equivalence (splitRelation s) := by
  constructor <;> grind [splitRelation]

variable [Fintype α] [Nonempty α]

theorem simon_group_case (σ : MultiplicativeLabeling G α) :
    ∃ (s : Split α (Fintype.card G)), isNormalized s ∧ isRamsey σ s := by
  let n := Fintype.card G
  let x₀ : α := Finset.min' (Finset.univ : Finset α) Finset.univ_nonempty

  let max_idx : Fin n := Fin.last (n - 1)
  let base_equiv := Fintype.equivFin G
  let index_of := base_equiv.trans (Equiv.swap (base_equiv 1) max_idx)

  have h_one_is_max : index_of 1 = max_idx := by
    simp [index_of, Equiv.swap_apply_left]

  let s : Split α n := fun y =>
    if y = x₀ then max_idx else index_of (σ.σ x₀ y)




end theorems